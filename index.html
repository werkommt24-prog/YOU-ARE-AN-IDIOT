<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>YOU ARE AN IDIOT ☻☻☻</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    /* Volle Seite sicher abdecken */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: black;
      color: white;
      font-family: monospace;
      -webkit-user-select: none;
      user-select: none;
      transition: background 0.06s linear, color 0.06s linear;
    }
    /* Zentrierter Inhalt (visuell) */
    .wrap {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    h1 {
      font-size: clamp(28px, 6vw, 64px);
      margin: 0;
      line-height: 1.1;
      text-align: center;
      pointer-events: none;
    }
    /* unsichtbarer Klickfänger (erstes Klick-Event) */
    #clickCatcher {
      position: fixed;
      inset: 0;
      background: transparent;
      border: 0;
      padding: 0;
      margin: 0;
      z-index: 9999;
      cursor: default;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>
      YOU ARE AN IDIOT<br />
      <span id="smiles" style="display:block;font-size:0.8em;margin-top:8px;">☻☻☻</span>
    </h1>
  </div>

  <!-- unsichtbarer Vollbild-Button für die erste Interaktion -->
  <button id="clickCatcher" aria-hidden="true"></button>

  <!-- Fallback-Audio-Tag (nutzt URL, wird zusätzlich via WebAudio dekodiert) -->
  <audio id="fallbackAudio" preload="auto" style="display:none" loop>
    <source src="https://ia800304.us.archive.org/27/items/youareanidiotdotorgflash/youareanidiot.mp3" type="audio/mpeg">
  </audio>

  <script>
    (function(){
      const clickCatcher = document.getElementById('clickCatcher');
      const fallbackAudio = document.getElementById('fallbackAudio');

      let active = false;
      let flasher = null;
      let popupCount = 0;
      const MAX_POPUPS = 6;
      const openPopups = new Set();

      // Versuche WebAudio-Playback (robuster gegenüber Autoplay), fallback auf <audio>
      let audioCtx = null;
      let bufferSource = null;

      async function prepareAndPlayAudio() {
        // Versuche WebAudio
        try {
          if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          // Falls already playing via <audio>, resume context and return
          if (audioCtx.state === 'suspended') await audioCtx.resume();

          // Lade MP3 via fetch und decode, nur einmal
          if (!audioCtx._decodedBuffer) {
            const resp = await fetch('https://ia800304.us.archive.org/27/items/youareanidiotdotorgflash/youareanidiot.mp3', { cache: 'force-cache' });
            const ab = await resp.arrayBuffer();
            audioCtx._decodedBuffer = await audioCtx.decodeAudioData(ab);
          }

          // Erstelle BufferSource und Loop
          bufferSource = audioCtx.createBufferSource();
          bufferSource.buffer = audioCtx._decodedBuffer;
          const gain = audioCtx.createGain();
          gain.gain.value = 0.14;
          bufferSource.loop = true;
          bufferSource.connect(gain).connect(audioCtx.destination);
          bufferSource.start(0);
          audioCtx._source = bufferSource;
          return;
        } catch (e) {
          // Falls WebAudio fehlschlägt, versuche <audio> Playback als Fallback
          try { fallbackAudio.play().catch(()=>{}); } catch(e2){}
        }
      }

      function stopAudio() {
        try {
          if (bufferSource) {
            try { bufferSource.stop(); } catch(e) {}
            bufferSource = null;
          }
          if (audioCtx) {
            try { audioCtx.close(); } catch(e) {}
            audioCtx = null;
          }
        } catch(e){}
        try {
          fallbackAudio.pause();
          fallbackAudio.currentTime = 0;
        } catch(e){}
      }

      // Vollseiten-Schwarz/Weiß-Flacker: schreibt direkt auf html + body + documentElement
      function startFlasher() {
        if (flasher) return;
        flasher = setInterval(() => {
          const cur = document.documentElement.style.backgroundColor || getComputedStyle(document.documentElement).backgroundColor || 'rgb(0,0,0)';
          const isBlack = cur === 'black' || cur === 'rgb(0, 0, 0)';
          const bg = isBlack ? 'white' : 'black';
          const fg = isBlack ? 'black' : 'white';
          // setze auf html und body, so ist die gesamte Seite betroffen
          document.documentElement.style.backgroundColor = bg;
          document.documentElement.style.color = fg;
          document.body.style.backgroundColor = bg;
          document.body.style.color = fg;
        }, 140);
      }

      function stopFlasher() {
        if (flasher) { clearInterval(flasher); flasher = null; }
        document.documentElement.style.backgroundColor = 'black';
        document.documentElement.style.color = 'white';
        document.body.style.backgroundColor = 'black';
        document.body.style.color = 'white';
      }

      // Popup-Inhalt: nur Text "YOU ARE AN IDIOT" und drei Smiles darunter
      function popupHtml() {
        return `<!doctype html><html><head><meta charset="utf-8"><title>YOU ARE AN IDIOT</title>
          <style>html,body{height:100%;margin:0;background:black;color:white;font-family:monospace;display:flex;align-items:center;justify-content:center;}
          h1{font-size:24px;margin:0;text-align:center} .sm{display:block;margin-top:8px;font-size:18px}</style>
          </head><body><div><h1>YOU ARE AN IDIOT</h1><span class="sm">☻☻☻</span></div></body></html>`;
      }

      function openOnePopup() {
        if (popupCount >= MAX_POPUPS) return;
        const left = Math.floor(Math.random()*200) + 20;
        const top = Math.floor(Math.random()*200) + 20;
        const specs = `width=420,height=320,left=${left},top=${top},menubar=no,toolbar=no,location=no,status=no`;
        const win = window.open('about:blank', '_blank', specs);
        if (!win) return;
        try {
          win.document.open();
          win.document.write(popupHtml());
          win.document.close();
        } catch(e) {}
        openPopups.add(win);
        popupCount++;
        // überwache, ob Fenster geschlossen wird
        const t = setInterval(() => {
          try {
            if (win.closed) {
              clearInterval(t);
              openPopups.delete(win);
            }
          } catch(e){}
        }, 800);
      }

      // Start: nach erstem Klick
      async function activateAll() {
        if (active) return;
        active = true;
        // Starte Audio (WebAudio bevorzugt, falls fehlschlägt: audio-Tag)
        await prepareAndPlayAudio();

        // Starte Flacker auf gesamter Seite
        startFlasher();

        // Öffne genau 6 Popups sequentiell mit kleinem Delay
        for (let i=0;i<MAX_POPUPS;i++){
          setTimeout(()=>openOnePopup(), i * 300);
        }

        // Entferne click catcher (um spätere Klicks nicht erneut auszulösen)
        try { clickCatcher.remove(); } catch(e){}
      }

      // Erst-Klick-Listener — startet alles
      clickCatcher.addEventListener('click', (e)=>{
        e.preventDefault();
        activateAll();
      }, { once: true, passive: false });

      // Optional: Esc schließt Popups und stoppt alles (nicht sichtbar per Anforderung, aber nützlich)
      document.addEventListener('keydown', (ev)=>{
        if (ev.key === 'Escape') {
          // schließen
          openPopups.forEach(w => { try { if (!w.closed) w.close(); } catch(e){} });
          openPopups.clear();
          popupCount = MAX_POPUPS; // verhindert weitere
          stopFlasher();
          stopAudio();
        }
      });

      // cleanup beim verlassen
      window.addEventListener('beforeunload', ()=> {
        openPopups.forEach(w=>{ try { if (!w.closed) w.close(); } catch(e){} });
      });
    })();
  </script>
</body>
</html>
